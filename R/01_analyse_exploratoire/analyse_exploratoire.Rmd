---
title: "Analyse Exploratoire"
output: 
  github_document:
    toc: true        # table des matières optionnelle
    fig_width: 6     # largeur des graphiques
    fig_height: 4    # hauteur des graphiques
---

```{r setup, include=FALSE}
# Pour les graphiques
install.packages("ggplot2")
install.packages("reshape2")
install.packages("e1071")
library(e1071)
library(ggplot2)
library(reshape2)

data <- read.csv("../../data/processed/credit_card_clean.csv")

# Afficher les premières lignes et structure
head(data)
str(data)

# Sélectionner les colonnes numériques uniquement
numeric_cols <- sapply(data, is.numeric)
num_cols <- names(data)[numeric_cols]
print(paste("Colonnes numériques trouvées:", paste(num_cols, collapse=", ")))
```

```{r statistiques_descriptives}

# Fonction pour le mode
get_mode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Calcul des statistiques complètes pour toutes les colonnes numériques
stats_completes <- data.frame(
  Variable = num_cols,
  Moyenne = sapply(data[, num_cols], mean, na.rm = TRUE),
  Mediane = sapply(data[, num_cols], median, na.rm = TRUE),
  Mode = sapply(data[, num_cols], get_mode),
  Ecart_type = sapply(data[, num_cols], sd, na.rm = TRUE),
  Variance = sapply(data[, num_cols], var, na.rm = TRUE),
  Min = sapply(data[, num_cols], min, na.rm = TRUE),
  Max = sapply(data[, num_cols], max, na.rm = TRUE),
  Skewness = sapply(data[, num_cols], function(x) skewness(x, na.rm = TRUE)),
  stringsAsFactors = FALSE
)

# Ajouter une colonne pour l'interprétation de l'asymétrie
stats_completes$Asymetrie <- ifelse(
  stats_completes$Skewness > 0, "Droite",
  ifelse(stats_completes$Skewness < 0, "Gauche", "Symétrique")
)

# Afficher le tableau
print(stats_completes)

# Quartiles (25%, 50%, 75%)
sapply(data[, num_cols], function(x) quantile(x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE))

# Percentiles (exemple : 10%, 90%)
sapply(data[, num_cols], function(x) quantile(x, probs = c(0.1, 0.9), na.rm = TRUE))
```

```{r barplot_stats}
# Vérifier que num_cols n'est pas vide
if (length(num_cols) > 0) {
  # Calculer moyenne et écart-type
  stats <- data.frame(
    variable = num_cols,
    mean = sapply(data[, num_cols], mean, na.rm = TRUE),
    sd = sapply(data[, num_cols], sd, na.rm = TRUE),
    stringsAsFactors = FALSE
  )
  
  # Barplot avec erreur ± écart-type
  print(ggplot(stats, aes(x = reorder(variable, mean), y = mean)) +
    geom_bar(stat="identity", fill="skyblue") +
    geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title="Moyenne ± Écart-type des variables", y="Valeur", x="Variable"))
} else {
  print("Erreur: Aucune colonne trouvée dans les données")
}
```

```{r histograms}
for (col in num_cols) {
  p <- ggplot(data, aes(x = .data[[col]])) +
    geom_histogram(fill="lightgreen", color="black", bins=30) +
    labs(title=paste("Distribution de", col), x=col, y="Fréquence")
  print(p)
}
```

```{r boxplots}
# Boxplot pour chaque variable
for (col in num_cols) {
  p <- ggplot(data, aes(y = .data[[col]])) +
    geom_boxplot(fill="pink", color="black") +
    labs(title=paste("Boxplot de", col), y=col) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank())
  print(p)
}
```

## Outliers (IQR) – BALANCE

```{r outliers_balance, message=FALSE}
# Détection des outliers via IQR pour BALANCE
Q1 <- quantile(data$BALANCE, 0.25, na.rm = TRUE)
Q3 <- quantile(data$BALANCE, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower <- Q1 - 1.5 * IQR
upper <- Q3 + 1.5 * IQR

outliers_balance <- subset(data, BALANCE < lower | BALANCE > upper)

# Récapitulatif clair (seuils et compte)
summary_outliers <- data.frame(
  variable = "BALANCE",
  lower = lower,
  upper = upper,
  n_outliers = nrow(outliers_balance)
)
print(summary_outliers)

# Top 10 outliers (colonnes clés uniquement)
if (nrow(outliers_balance) > 0) {
  key_cols <- intersect(c("BALANCE","CREDIT_LIMIT","PAYMENTS","PURCHASES","CASH_ADVANCE","PRC_FULL_PAYMENT"), names(outliers_balance))
  outliers_view <- outliers_balance[order(outliers_balance$BALANCE, decreasing = TRUE), key_cols, drop = FALSE]
  print(utils::head(outliers_view, 10))
} else {
  print("Aucun outlier détecté pour BALANCE selon la règle IQR.")
}
```

## Visualisation Graphique des Outliers

```{r outliers_visualization, message=FALSE, fig.width=10, fig.height=8}
# 1. Boxplot avec identification des outliers pour BALANCE
ggplot(data, aes(y = BALANCE)) +
  geom_boxplot(fill = "lightblue", outlier.colour = "red", outlier.size = 2) +
  labs(title = "Outliers de BALANCE (en rouge)", 
       y = "Balance") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

# 2. Boxplots multiples pour toutes les variables numériques
if (length(num_cols) > 0) {
  # Normaliser les données pour comparaison
  data_norm <- as.data.frame(scale(data[, num_cols]))
  data_norm$ID <- 1:nrow(data_norm)
  
  # Transformer en format long pour ggplot
  data_long <- melt(data_norm, id.vars = "ID", variable.name = "Variable", value.name = "Value")
  
  ggplot(data_long, aes(x = Variable, y = Value)) +
    geom_boxplot(fill = "lightgreen", outlier.colour = "red", outlier.size = 1.5) +
    labs(title = "Outliers de toutes les variables (données normalisées)", 
         x = "Variables", 
         y = "Valeur normalisée") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# 3. Scatter plot avec identification des outliers pour BALANCE vs CREDIT_LIMIT
if ("CREDIT_LIMIT" %in% names(data)) {
  data$is_outlier_balance <- ifelse(data$BALANCE < lower | data$BALANCE > upper, "Outlier", "Normal")
  
  ggplot(data, aes(x = CREDIT_LIMIT, y = BALANCE, color = is_outlier_balance)) +
    geom_point(alpha = 0.5, size = 2) +
    scale_color_manual(values = c("Normal" = "blue", "Outlier" = "red")) +
    labs(title = "Outliers de BALANCE en fonction de CREDIT_LIMIT", 
         x = "Credit Limit", 
         y = "Balance",
         color = "Type") +
    theme_minimal()
}

# 4. Density plot avec zones d'outliers
ggplot(data, aes(x = BALANCE)) +
  geom_density(fill = "lightblue", alpha = 0.5) +
  geom_vline(xintercept = lower, color = "red", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = upper, color = "red", linetype = "dashed", linewidth = 1) +
  annotate("text", x = lower, y = 0, label = paste("Q1-1.5*IQR:", round(lower, 2)), 
           hjust = 1.1, color = "red") +
  annotate("text", x = upper, y = 0, label = paste("Q3+1.5*IQR:", round(upper, 2)), 
           hjust = -0.1, color = "red") +
  labs(title = "Distribution de BALANCE avec limites d'outliers", 
       x = "Balance", 
       y = "Densité") +
  theme_minimal()
```

```{r outliers_all_variables, message=FALSE, fig.width=12, fig.height=10}
# 5. Détection et visualisation des outliers pour toutes les variables
outliers_summary <- data.frame()

for (col in num_cols) {
  Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
  IQR_val <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_val
  upper_bound <- Q3 + 1.5 * IQR_val
  
  n_outliers <- sum(data[[col]] < lower_bound | data[[col]] > upper_bound, na.rm = TRUE)
  pct_outliers <- round(100 * n_outliers / nrow(data), 2)
  
  outliers_summary <- rbind(outliers_summary, data.frame(
    Variable = col,
    Q1 = Q1,
    Q3 = Q3,
    IQR = IQR_val,
    Lower = lower_bound,
    Upper = upper_bound,
    N_Outliers = n_outliers,
    Pct_Outliers = pct_outliers
  ))
}

# Afficher le tableau récapitulatif
print(outliers_summary)

# Graphique à barres du pourcentage d'outliers par variable
ggplot(outliers_summary, aes(x = reorder(Variable, -Pct_Outliers), y = Pct_Outliers)) +
  geom_bar(stat = "identity", fill = "coral") +
  geom_text(aes(label = paste0(Pct_Outliers, "%")), vjust = -0.5, size = 3) +
  labs(title = "Pourcentage d'outliers par variable", 
       x = "Variable", 
       y = "% d'outliers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
## Détection détaillée des outliers pour chaque variable

```{r outliers_individuels, message=FALSE, fig.width=10, fig.height=6}
# Pour chaque variable numérique, créer des visualisations détaillées
for (col in num_cols) {
  cat("\n### Variable:", col, "\n\n")
  
  # Calcul des seuils IQR
  Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
  IQR_val <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_val
  upper_bound <- Q3 + 1.5 * IQR_val
  
  # Identification des outliers
  outliers_mask <- data[[col]] < lower_bound | data[[col]] > upper_bound
  n_outliers <- sum(outliers_mask, na.rm = TRUE)
  pct_outliers <- round(100 * n_outliers / nrow(data), 2)
  
  # Afficher les statistiques
  cat("- Nombre d'outliers:", n_outliers, "/", nrow(data), "(", pct_outliers, "%)\n")
  cat("- Limites: [", round(lower_bound, 2), ",", round(upper_bound, 2), "]\n")
  cat("- Q1 =", round(Q1, 2), ", Q3 =", round(Q3, 2), ", IQR =", round(IQR_val, 2), "\n\n")
  
  # Créer une colonne pour identifier les outliers
  data$outlier_status <- ifelse(outliers_mask, "Outlier", "Normal")
  
  # 1. Boxplot individuel avec outliers en rouge
  p1 <- ggplot(data, aes(y = .data[[col]])) +
    geom_boxplot(fill = "lightblue", outlier.colour = "red", outlier.size = 2) +
    labs(title = paste("Boxplot de", col), 
         y = col) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank())
  print(p1)
  
  # 2. Density plot avec zones d'outliers
  p2 <- ggplot(data, aes(x = .data[[col]])) +
    geom_density(fill = "lightgreen", alpha = 0.5) +
    geom_vline(xintercept = lower_bound, color = "red", linetype = "dashed", linewidth = 1) +
    geom_vline(xintercept = upper_bound, color = "red", linetype = "dashed", linewidth = 1) +
    geom_vline(xintercept = Q1, color = "blue", linetype = "dotted", linewidth = 0.8) +
    geom_vline(xintercept = Q3, color = "blue", linetype = "dotted", linewidth = 0.8) +
    labs(title = paste("Distribution de", col, "avec limites d'outliers"), 
         x = col, 
         y = "Densité") +
    theme_minimal()
  print(p2)
  
  # 3. Scatter plot avec index pour voir la position des outliers
  p3 <- ggplot(data, aes(x = 1:nrow(data), y = .data[[col]], color = outlier_status)) +
    geom_point(alpha = 0.6, size = 1.5) +
    scale_color_manual(values = c("Normal" = "blue", "Outlier" = "red")) +
    labs(title = paste("Outliers de", col, "par observation"), 
         x = "Index", 
         y = col,
         color = "Type") +
    theme_minimal()
  print(p3)
  
  # Afficher quelques exemples d'outliers si présents
  if (n_outliers > 0 & n_outliers <= 20) {
    cat("\nTous les outliers détectés:\n")
    outliers_data <- data[outliers_mask, c(col), drop = FALSE]
    print(outliers_data[order(outliers_data[[col]], decreasing = TRUE), , drop = FALSE])
  } else if (n_outliers > 20) {
    cat("\nTop 10 outliers (valeurs les plus extrêmes):\n")
    outliers_data <- data[outliers_mask, c(col), drop = FALSE]
    print(utils::head(outliers_data[order(abs(outliers_data[[col]] - median(data[[col]], na.rm = TRUE)), decreasing = TRUE), , drop = FALSE], 10))
  }
  
  cat("\n---\n")
}
```

## Matrice de corrélation des outliers

```{r correlation_outliers, message=FALSE, fig.width=10, fig.height=8}
# Créer une matrice binaire indiquant si chaque observation est un outlier pour chaque variable
outliers_matrix <- data.frame(matrix(0, nrow = nrow(data), ncol = length(num_cols)))
colnames(outliers_matrix) <- num_cols

for (i in seq_along(num_cols)) {
  col <- num_cols[i]
  Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
  IQR_val <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR_val
  upper_bound <- Q3 + 1.5 * IQR_val
  
  outliers_matrix[, i] <- ifelse(data[[col]] < lower_bound | data[[col]] > upper_bound, 1, 0)
}

# Vérifier quelles colonnes ont une variance non nulle (au moins un outlier et au moins une valeur normale)
valid_cols <- sapply(outliers_matrix, function(x) {
  var_x <- var(x, na.rm = TRUE)
  !is.na(var_x) && var_x > 0
})

cat("Variables avec outliers détectés:\n")
cat(paste(num_cols[valid_cols], collapse = ", "), "\n\n")

if (sum(valid_cols) > 1) {
  # Calculer la corrélation uniquement pour les colonnes avec variance non nulle
  cor_outliers <- cor(outliers_matrix[, valid_cols], use = "complete.obs")
  
  # Heatmap de corrélation
  cor_melted <- melt(cor_outliers)
  print(ggplot(cor_melted, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile() +
    geom_text(aes(label = round(value, 2)), size = 3) +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                         midpoint = 0, limit = c(-1, 1)) +
    labs(title = "Corrélation entre les outliers des variables", 
         x = "", y = "", fill = "Corrélation") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)))
  
  # Afficher les variables qui ont tendance à avoir des outliers ensemble
  cat("\nVariables avec forte corrélation d'outliers (> 0.5):\n")
  high_cor <- which(cor_outliers > 0.5 & cor_outliers < 1, arr.ind = TRUE)
  if (nrow(high_cor) > 0) {
    for (i in 1:nrow(high_cor)) {
      var1 <- rownames(cor_outliers)[high_cor[i, 1]]
      var2 <- colnames(cor_outliers)[high_cor[i, 2]]
      cor_val <- cor_outliers[high_cor[i, 1], high_cor[i, 2]]
      cat(var1, "<->", var2, ":", round(cor_val, 3), "\n")
    }
  } else {
    cat("Aucune forte corrélation détectée.\n")
  }
} else {
  cat("Impossible de calculer la corrélation : pas assez de variables avec des outliers.\n")
  if (sum(valid_cols) == 0) {
    cat("Aucune variable n'a d'outliers détectés.\n")
  } else {
    cat("Une seule variable a des outliers :", num_cols[valid_cols], "\n")
  }
}
```
